name: 'autoversion'
description: 'automatically bump versions'
inputs:
  github_token:
    description: 'API Token for Github'
    required: true
  openai_token:
    description: 'API Token for OpenAI'
    required: true
runs:
  using: "composite"
  steps:
    - name: "Install Dependencies"
      env:
        OPENAI_TOKEN: ${{ inputs.openai_token }}
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y debconf-utils wget jq
        echo openai openai/OPENAI_API_TOKEN string "$OPENAI_TOKEN" | sudo debconf-set-selections
        wget -O - https://raw.githubusercontent.com/plengauer/openai/main/INSTALL.sh | sh
    - name: "Checkout"
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token }}
        fetch-depth: 0
    - name: "Search and Bump Versions"
      shell: bash
      run: |
        list_version_files() {
          find . | grep -E '/VERSION$|/DEBIAN/control$|/package.json$|.toml$|.gemspec$'
        }

        is_version_touched() {
          local version_file="$1"
          local commit_id="$2"
          case "$version_file" in
            */VERSION) return 0;;
            */DEBIAN/control) git diff "$commit_id"^ "$commit_id" -- "${version_file#./}" | grep -qE '^+Version: ' && return 0 || return 1;;
            */package.json) git diff "$commit_id"^ "$commit_id" -- "${version_file#./}" | grep -qE '^+' | grep -qE '"version"' && return 0 || return 1;;
            *.gemspec) git diff "$commit_id"^ "$commit_id" -- "${version_file#./}" | grep -qE '^+' | grep -qE '.version' && return 0 || return 1;;
            *.toml) git diff "$commit_id"^ "$commit_id" -- "${version_file#./}" | grep -qE '^+' | grep -qE 'version' && return 0 || return 1;;
            *) echo "Here be dragons! (version file $version_file)" >&2; return 1;;
          esac
          return 0
        }
        
        read_version() {
          local version_file="$1"
          case "$version_file" in
            */VERSION) cat "$version_file";;
            */DEBIAN/control) cat "$version_file" | grep -E '^Version: ' | cut -d ' ' -f 2-;;
            */package.json) cat "$version_file" | jq -r .version;;
            *.gemspec) cat "$version_file" | grep version | cut -d = -f 2 | awk '{ print $1 }' | tr -d "'"'"';;
            *.toml) cat "$version_file" | grep version | cut -d = -f 2 | awk '{ print $1 }' | tr -d "'"'"';;
            *) echo "Here be dragons! (version file $version_file)" >&2; return 1;;
          esac
        }
        
        write_version() {
          local version_file="$1"
          local version_string="$2"
          local version_string_new="$3"
          case "$version_file" in
            */VERSION) echo -n "$version_string_new" > "$version_file";;
            */DEBIAN/control) sed -i "s/^Version: .*/Version: $version_string_new/" "$version_file";;
            */package.json) jq --arg version "$version_string" '.version = $version' "$version_file" > tmp.$$.json && mv tmp.$$.json "$version_file" && rm tmp.$$.json;;
            *.gemspec) sed -i "s/$version_string/$version_string_new/g" "$version_file";;
            *.toml) sed -i "s/$version_string/$version_string_new/g" "$version_file";;
            *) echo "Here be dragons! (version file $version_file)" >&2; return 1;;
          esac
        }

        increment_version() {
          local version_string="$1"
          local change_type="$2"
          major="$(echo "$version_string" | cut -d . -f 1)"
          minor="$(echo "$version_string" | cut -d . -f 2)"
          patch="$(echo "$version_string" | cut -d . -f 3)"
          if [ "$major.$minor.$patch" != "$version_string" ]; then echo "Version format not supported! ($version_string)" >&2; exit 1; fi
          case "$change_type" in
            major) major="$((major + 1))"; minor=0; patch=0;;
            minor) minor="$((minor + 1))"; patch=0;;
            patch) patch="$((patch + 1))";;
            *) echo "Here be dragons! (change type $change_type)" >&2; return 1;;
          esac
          echo "$major.$minor.$patch"
        }

        export AI_SYSTEM_PROMPT="I take input that are commit messages and analyze whether the maximum change is either major, minor or patch. Major changes are for breaking changes, minor for new features, dependency updates, and other new functionality that does not break existing functionality, patch is for bug fixes only. If the commit messages hint at more than one type of a change, I respond with the highest one. I only respond with major, minor, or patch, nothing else."
        list_version_files | while read -r version_file; do
          echo "processing $version_file ..." >&2
          directory="$(echo "$version_file" | rev | cut -d '/' -f 2- | rev)"
          case "$version_file" in
            */DEBIAN/control) directory="$(echo "$directory" | rev | cut -d '/' -f 2- | rev)";;
            */package.json) if ! jq '.version' "$version_file" &> /dev/null; then continue; fi
          esac
          git log --oneline | cut -d ' ' -f 1 | while read -r commit_id; do
            if ! git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qE '^'"${directory#./}"; then echo "skipping $commit_id" >&2; continue; fi
            if git diff-tree --no-commit-id --name-only -r "$commit_id" | grep -qF "${version_file#./}" && is_version_touched "$version_file" "$commit_id"; then echo "stopping at $commit_id" >&2; break; fi
            echo "including $commit_id" >&2
            echo "$commit_id"
          done | while read -r commit_id; do git log -1 --format=%B "$commit_id"; done | { grep -vE '^$' || true; } | xargs -r ai | sort -u -r | while read -r change_type; do
            echo "bumping $change_type version in $version_file" >&2
            version_string="$(read_version "$version_file")"
            if [ -z "$version_string" ]; then break; fi
            version_string_new="$(increment_version "$version_string" "$change_type")"
            write_version "$version_file" "$version_string" "$version_string_new"
          done
        done
    - name: "Resolve Reviewers"
      id: reviewers
      run: |
        if ! [ -f .github/renovate.json ]; then exit 0; fi
        echo "reviewers=$(cat .github/renovate.json | jq -r '.reviewers | join(",")')" > "$GITUB_OUTPUT"
    - name: "Open Pull Request"
      id: open-pr
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ inputs.github_token }}
        commit-message: "Bump Version"
        branch: "versionbump"
        title: "Automatic Version Bump"
        body: |
          This PR bumps version(s) to trigger a release.
          (this PR is automatically generated)
        reviewers: ${{ steps.reviewers.outputs.reviewers }}
        delete-branch: true
    - uses: peter-evans/enable-pull-request-automerge@v3
      if: steps.open-pr.outputs.pull-request-number != null
      with:
        token: ${{ inputs.github_token }}
        pull-request-number: ${{ steps.open-pr.outputs.pull-request-number }}
        merge-method: squash
